/*
 * 题目：旋转数组的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个升序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
 * 数组可能包含重复项。
 * 注意：数组内所含元素非负，若数组大小为0，请返回-1。
 * 样例
 * 输入：nums=[2,2,2,0,1]
 * 输出：0
 */
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size()-1;//取最后一个数的位置
        //若数组为空，则直接返回-1
        if(n < 0)
            return -1;
        //获得第二个数组中第一个小于第一个数组的首元素的元素位置
        //或者遍历完了第二个数组获得第一个数组的最后一个元素的位置（比如3,4,5,3,3,3,3）
        while (n > 0 && nums[n] == nums[0])n--;
        //若分界线位置的数组元素都等于初始元素，则说明最小值就是初始元素
        //因为上述两种情况都说明不管是遍历完第二个数组，或者到了第一个数组最后一个数字，最小值就是第一个数字
        if(nums[n] >= nums[0])
            return nums[0];
        //现在处理正常情况，即左边数组大于右边数组的情况（比如：4,4,5,1,2,3）
        int i = 0;
        int r = n;//n现在所指的位置是第二个数组的最后一位数字
        while (i < r){
            int mid = i + r >> 1;// [l, mid], [mid + 1, r],字位右移运算符,向右移动一位相当于/2取整，取中间的位置
            if(nums[mid] < nums[0]) r = mid;//若中间位置的元素小于第一个元素，说明该位置在第二个数组中，可将r对应的位置进行更新
            else i = mid + 1;//若该位置的数值大于第一个元素，那么说明该位置在第一个数组中，可将该位置数+1赋值给i继续寻找第二数组的首位元素
        }
        return nums[r];
    }
};
